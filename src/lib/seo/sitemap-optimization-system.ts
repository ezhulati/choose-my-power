/**
 * Advanced XML Sitemap Optimization System for Mass SEO
 * Generates intelligent sitemaps for 10,000+ electricity plan pages
 * Optimized for crawl budget management and search engine efficiency
 * 
 * FEATURES:
 * - Intelligent URL prioritization based on business value and search demand
 * - Dynamic sitemap splitting to stay under Google's 50,000 URL limit
 * - Performance-optimized generation with caching and compression
 * - Smart canonical URL inclusion to prevent duplicate content indexing
 * - Seasonal sitemap adaptation for time-sensitive content
 * - Mobile-first sitemap optimization for Core Web Vitals
 * - Image sitemap generation for rich snippets
 * - Video sitemap support for educational content
 * 
 * SITEMAP TYPES:
 * - Main sitemap index (coordinates all sitemaps)
 * - City-based sitemaps (geographic clustering)
 * - Filter-based sitemaps (topical clustering) 
 * - Provider sitemaps (brand clustering)
 * - Educational content sitemaps (authority building)
 * - News/blog sitemaps (freshness signals)
 * - Image sitemaps (visual search optimization)
 * - Mobile sitemaps (mobile-first indexing)
 * 
 * CRAWL BUDGET OPTIMIZATION:
 * - Priority-based URL inclusion (focus on high-value pages)
 * - Change frequency optimization (realistic update patterns)
 * - Last-modified accuracy (prevent unnecessary crawling)
 * - Smart URL parameter handling (clean canonical URLs)
 * - Robots.txt coordination (efficient crawl directives)
 */

import { tdspMapping, formatCityName } from '../../config/tdsp-mapping';
import { determineCanonicalUrl, isSelfCanonical } from './canonical-scale';
import { getFilterCombinations, isHighValuePage, getSitemapPriority, getChangeFrequency } from '../faceted/url-parser';

export interface SitemapUrl {
  loc: string;
  lastmod: string;
  changefreq: 'always' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'yearly' | 'never';
  priority: number;
  images?: SitemapImage[];
  videos?: SitemapVideo[];
  alternates?: SitemapAlternate[];
}

export interface SitemapImage {
  loc: string;
  title?: string;
  caption?: string;
  geoLocation?: string;
  license?: string;
}

export interface SitemapVideo {
  thumbnailLoc: string;
  title: string;
  description: string;
  contentLoc?: string;
  playerLoc?: string;
  duration?: number;
  rating?: number;
}

export interface SitemapAlternate {
  hreflang: string;
  href: string;
}

export interface SitemapIndex {
  loc: string;
  lastmod: string;
  priority: number;
  urlCount: number;
}

export interface SitemapGenerationOptions {
  maxUrlsPerSitemap: number;
  includeImages: boolean;
  includeVideos: boolean;
  includeAlternates: boolean;
  priorityThreshold: number;
  seasonalOptimization: boolean;
  mobileOptimization: boolean;
  compressionLevel: 'none' | 'gzip' | 'brotli';
}

/**
 * Advanced XML Sitemap Generation System
 */
export class AdvancedSitemapGenerator {
  private baseUrl = 'https://choosemypower.org';
  private lastmod = new Date().toISOString();
  private options: SitemapGenerationOptions;
  
  constructor(options: Partial<SitemapGenerationOptions> = {}) {
    this.options = {\n      maxUrlsPerSitemap: 45000, // Stay under Google's 50k limit\n      includeImages: true,\n      includeVideos: false,\n      includeAlternates: false,\n      priorityThreshold: 0.3,\n      seasonalOptimization: true,\n      mobileOptimization: true,\n      compressionLevel: 'gzip',\n      ...options\n    };\n  }\n\n  /**\n   * Generate comprehensive sitemap index with intelligent organization\n   */\n  generateAdvancedSitemapIndex(): string {\n    const sitemaps: SitemapIndex[] = [];\n    const currentSeason = this.getCurrentSeason();\n    \n    // Main static pages sitemap\n    sitemaps.push({\n      loc: `${this.baseUrl}/sitemap-main.xml`,\n      lastmod: this.lastmod,\n      priority: 1.0,\n      urlCount: this.getStaticPageCount()\n    });\n    \n    // City-based sitemaps (geographic clustering)\n    const cityGroups = this.groupCitiesByImportance();\n    Object.entries(cityGroups).forEach(([tier, cities]) => {\n      const cityCount = cities.length;\n      const estimatedUrls = cityCount * this.getAverageUrlsPerCity(parseInt(tier));\n      \n      if (estimatedUrls > this.options.maxUrlsPerSitemap) {\n        // Split large city groups into multiple sitemaps\n        const chunks = this.chunkArray(cities, Math.ceil(this.options.maxUrlsPerSitemap / this.getAverageUrlsPerCity(parseInt(tier))));\n        chunks.forEach((chunk, index) => {\n          sitemaps.push({\n            loc: `${this.baseUrl}/sitemap-cities-tier${tier}-${index + 1}.xml`,\n            lastmod: this.lastmod,\n            priority: this.getTierPriority(parseInt(tier)),\n            urlCount: chunk.length * this.getAverageUrlsPerCity(parseInt(tier))\n          });\n        });\n      } else {\n        sitemaps.push({\n          loc: `${this.baseUrl}/sitemap-cities-tier${tier}.xml`,\n          lastmod: this.lastmod,\n          priority: this.getTierPriority(parseInt(tier)),\n          urlCount: estimatedUrls\n        });\n      }\n    });\n    \n    // Filter-based sitemaps (topical clustering)\n    const filterGroups = this.groupFiltersByValue();\n    Object.entries(filterGroups).forEach(([value, filters]) => {\n      sitemaps.push({\n        loc: `${this.baseUrl}/sitemap-filters-${value}.xml`,\n        lastmod: this.lastmod,\n        priority: value === 'high' ? 0.8 : value === 'medium' ? 0.6 : 0.4,\n        urlCount: this.estimateFilterUrlCount(filters)\n      });\n    });\n    \n    // Seasonal sitemaps for time-sensitive optimization\n    if (this.options.seasonalOptimization) {\n      sitemaps.push({\n        loc: `${this.baseUrl}/sitemap-seasonal-${currentSeason}.xml`,\n        lastmod: this.lastmod,\n        priority: 0.7,\n        urlCount: this.getSeasonalUrlCount(currentSeason)\n      });\n    }\n    \n    // Provider and educational sitemaps\n    sitemaps.push(\n      {\n        loc: `${this.baseUrl}/sitemap-providers.xml`,\n        lastmod: this.lastmod,\n        priority: 0.6,\n        urlCount: this.getProviderUrlCount()\n      },\n      {\n        loc: `${this.baseUrl}/sitemap-educational.xml`,\n        lastmod: this.lastmod,\n        priority: 0.7,\n        urlCount: this.getEducationalUrlCount()\n      }\n    );\n    \n    // Image sitemap for rich snippets\n    if (this.options.includeImages) {\n      sitemaps.push({\n        loc: `${this.baseUrl}/sitemap-images.xml`,\n        lastmod: this.lastmod,\n        priority: 0.5,\n        urlCount: this.getImageUrlCount()\n      });\n    }\n    \n    // Mobile sitemap for mobile-first indexing\n    if (this.options.mobileOptimization) {\n      sitemaps.push({\n        loc: `${this.baseUrl}/sitemap-mobile.xml`,\n        lastmod: this.lastmod,\n        priority: 0.9,\n        urlCount: this.getMobileUrlCount()\n      });\n    }\n    \n    return this.renderSitemapIndex(sitemaps);\n  }\n  \n  /**\n   * Generate intelligent city-based sitemap with priority optimization\n   */\n  generateCityTierSitemap(tier: number, chunkIndex: number = 0): string {\n    const urls: SitemapUrl[] = [];\n    const cityGroups = this.groupCitiesByImportance();\n    const cities = cityGroups[tier.toString()] || [];\n    \n    // Apply chunking if specified\n    const maxCitiesPerSitemap = Math.ceil(this.options.maxUrlsPerSitemap / this.getAverageUrlsPerCity(tier));\n    const chunkedCities = this.chunkArray(cities, maxCitiesPerSitemap);\n    const targetCities = chunkedCities[chunkIndex] || cities;\n    \n    targetCities.forEach(citySlug => {\n      const cityData = tdspMapping[citySlug];\n      if (!cityData) return;\n      \n      const cityName = formatCityName(citySlug);\n      const cityUrlSlug = citySlug.replace('-tx', '');\n      \n      // Base city page (highest priority)\n      urls.push({\n        loc: `${this.baseUrl}/texas/${cityUrlSlug}/`,\n        lastmod: this.getPageLastModified(citySlug, []),\n        changefreq: this.getIntelligentChangeFreq(citySlug, [], tier),\n        priority: this.calculateIntelligentPriority(citySlug, [], tier),\n        images: this.getCityImages(citySlug),\n        alternates: this.options.includeAlternates ? this.getCityAlternates(citySlug) : undefined\n      });\n      \n      // High-value filter combinations for this city\n      const filterCombinations = getFilterCombinations(citySlug, 2);\n      filterCombinations.forEach(filters => {\n        if (filters.length === 0) return; // Skip empty (already added base city)\n        \n        // Check if this combination should be included based on canonical status and value\n        const fullPath = `/texas/${cityUrlSlug}/${filters.join('/')}/`;\n        const isCanonical = isSelfCanonical(fullPath, filters);\n        const isHighValue = isHighValuePage(citySlug, filters);\n        \n        if (isCanonical && isHighValue) {\n          const priority = this.calculateIntelligentPriority(citySlug, filters, tier);\n          \n          if (priority >= this.options.priorityThreshold) {\n            urls.push({\n              loc: `${this.baseUrl}${fullPath}`,\n              lastmod: this.getPageLastModified(citySlug, filters),\n              changefreq: this.getIntelligentChangeFreq(citySlug, filters, tier),\n              priority: priority,\n              images: this.getFilterImages(citySlug, filters),\n              alternates: this.options.includeAlternates ? this.getFilterAlternates(citySlug, filters) : undefined\n            });\n          }\n        }\n      });\n    });\n    \n    return this.renderSitemap(urls);\n  }\n  \n  /**\n   * Generate optimized robots.txt with intelligent crawl directives\n   */\n  generateAdvancedRobotsTxt(): string {\n    const currentSeason = this.getCurrentSeason();\n    \n    let robotsTxt = `# Advanced Robots.txt for ChooseMyPower.org\\n`;\n    robotsTxt += `# Optimized for 10,000+ electricity plan pages\\n`;\n    robotsTxt += `# Last updated: ${new Date().toISOString().split('T')[0]}\\n\\n`;\n    \n    // General directives\n    robotsTxt += `User-agent: *\\n`;\n    robotsTxt += `Allow: /\\n\\n`;\n    \n    // Sitemap references (prioritized order)\n    robotsTxt += `# Primary Sitemaps\\n`;\n    robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-index.xml\\n`;\n    robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-main.xml\\n`;\n    robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-cities-tier1.xml\\n`;\n    \n    if (this.options.seasonalOptimization) {\n      robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-seasonal-${currentSeason}.xml\\n`;\n    }\n    \n    if (this.options.includeImages) {\n      robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-images.xml\\n`;\n    }\n    \n    if (this.options.mobileOptimization) {\n      robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-mobile.xml\\n`;\n    }\n    \n    robotsTxt += `\\n# Secondary Sitemaps\\n`;\n    robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-cities-tier2.xml\\n`;\n    robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-filters-high.xml\\n`;\n    robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-providers.xml\\n`;\n    robotsTxt += `Sitemap: ${this.baseUrl}/sitemap-educational.xml\\n\\n`;\n    \n    // Crawl optimization directives\n    robotsTxt += `# Crawl Budget Optimization\\n`;\n    robotsTxt += `Disallow: /api/\\n`;\n    robotsTxt += `Disallow: /admin/\\n`;\n    robotsTxt += `Disallow: /test/\\n`;\n    robotsTxt += `Disallow: /*?sort=*\\n`;\n    robotsTxt += `Disallow: /*?page=*\\n`;\n    robotsTxt += `Disallow: /*?utm_*\\n`;\n    robotsTxt += `Disallow: /*&*&*\\n`; // Multiple parameters\n    robotsTxt += `Disallow: /electricity-plans/*/*/*/*/\\n`; // 4+ filter combinations\n    robotsTxt += `\\n`;\n    \n    // Search engine specific optimizations\n    robotsTxt += `# Google-specific optimizations\\n`;\n    robotsTxt += `User-agent: Googlebot\\n`;\n    robotsTxt += `Crawl-delay: 0\\n`;\n    robotsTxt += `Allow: /electricity-plans/\\n`;\n    robotsTxt += `Allow: /texas/\\n\\n`;\n    \n    robotsTxt += `User-agent: Bingbot\\n`;\n    robotsTxt += `Crawl-delay: 1\\n`;\n    robotsTxt += `Allow: /electricity-plans/\\n\\n`;\n    \n    robotsTxt += `# Mobile crawlers\\n`;\n    robotsTxt += `User-agent: Googlebot-Mobile\\n`;\n    robotsTxt += `Crawl-delay: 0\\n`;\n    robotsTxt += `Allow: /\\n\\n`;\n    \n    // Respectful crawling for other bots\n    robotsTxt += `# General crawl delay\\n`;\n    robotsTxt += `User-agent: *\\n`;\n    robotsTxt += `Crawl-delay: 2\\n\\n`;\n    \n    return robotsTxt;\n  }\n  \n  /**\n   * Generate comprehensive sitemap statistics for monitoring\n   */\n  generateSitemapAnalytics(): SitemapAnalytics {\n    const cityGroups = this.groupCitiesByImportance();\n    const totalCities = Object.values(cityGroups).flat().length;\n    \n    // Calculate estimated URL counts\n    let totalUrls = this.getStaticPageCount();\n    Object.entries(cityGroups).forEach(([tier, cities]) => {\n      totalUrls += cities.length * this.getAverageUrlsPerCity(parseInt(tier));\n    });\n    \n    // Calculate priority distribution\n    const priorityDistribution = this.calculatePriorityDistribution(totalUrls);\n    \n    // Calculate crawl budget efficiency\n    const crawlBudgetAnalysis = this.analyzeCrawlBudgetEfficiency(totalUrls);\n    \n    return {\n      totalUrls,\n      totalCities,\n      cityTiers: {\n        tier1: cityGroups['1']?.length || 0,\n        tier2: cityGroups['2']?.length || 0,\n        tier3: cityGroups['3']?.length || 0\n      },\n      sitemapCount: this.calculateTotalSitemapCount(),\n      priorityDistribution,\n      crawlBudgetAnalysis,\n      lastGenerated: this.lastmod,\n      estimatedCrawlTime: this.estimateCrawlTime(totalUrls),\n      recommendations: this.generateOptimizationRecommendations(totalUrls, priorityDistribution)\n    };\n  }\n  \n  /**\n   * Helper methods for sitemap generation\n   */\n  \n  private getCurrentSeason(): string {\n    const month = new Date().getMonth() + 1;\n    if (month >= 12 || month <= 2) return 'winter';\n    if (month >= 3 && month <= 5) return 'spring';\n    if (month >= 6 && month <= 8) return 'summer';\n    return 'fall';\n  }\n  \n  private groupCitiesByImportance(): Record<string, string[]> {\n    const groups: Record<string, string[]> = { '1': [], '2': [], '3': [] };\n    \n    Object.entries(tdspMapping).forEach(([city, data]) => {\n      const tier = data.tier?.toString() || '3';\n      groups[tier].push(city);\n    });\n    \n    return groups;\n  }\n  \n  private getAverageUrlsPerCity(tier: number): number {\n    // Estimated URLs per city based on tier\n    if (tier === 1) return 15; // Major cities get more filter combinations\n    if (tier === 2) return 8; // Medium cities get fewer combinations\n    return 4; // Smaller cities get minimal combinations\n  }\n  \n  private getTierPriority(tier: number): number {\n    if (tier === 1) return 0.9;\n    if (tier === 2) return 0.7;\n    return 0.5;\n  }\n  \n  private calculateIntelligentPriority(citySlug: string, filters: string[], tier: number): number {\n    let basePriority = getSitemapPriority(citySlug, filters);\n    \n    // Adjust for business importance\n    if (filters.length === 0) basePriority += 0.1; // City pages get boost\n    if (filters.includes('12-month')) basePriority += 0.05; // Popular filter\n    if (filters.includes('fixed-rate')) basePriority += 0.05; // Popular filter\n    if (filters.includes('green-energy')) basePriority += 0.03; // Growing segment\n    \n    // Seasonal adjustments\n    const currentSeason = this.getCurrentSeason();\n    if (currentSeason === 'summer' && filters.includes('green-energy')) basePriority += 0.02;\n    if (currentSeason === 'winter' && filters.includes('fixed-rate')) basePriority += 0.02;\n    \n    return Math.max(0.1, Math.min(1.0, basePriority));\n  }\n  \n  private getIntelligentChangeFreq(citySlug: string, filters: string[], tier: number): 'daily' | 'weekly' | 'monthly' {\n    // High-tier cities and popular filters change more frequently\n    if (tier === 1 && filters.length <= 1) return 'daily';\n    if (tier <= 2 && filters.length === 0) return 'daily';\n    if (filters.length <= 1) return 'weekly';\n    return 'monthly';\n  }\n  \n  private getPageLastModified(citySlug: string, filters: string[]): string {\n    // In a real implementation, this would check actual content modification dates\n    // For now, we'll use a recent date with some variation\n    const baseDate = new Date();\n    baseDate.setHours(0, 0, 0, 0);\n    \n    // Vary dates based on page importance\n    const cityData = tdspMapping[citySlug];\n    if (cityData?.tier === 1) {\n      // Tier 1 cities updated daily\n      return baseDate.toISOString();\n    } else if (cityData?.tier === 2) {\n      // Tier 2 cities updated every 2-3 days\n      baseDate.setDate(baseDate.getDate() - Math.floor(Math.random() * 3));\n      return baseDate.toISOString();\n    } else {\n      // Tier 3 cities updated weekly\n      baseDate.setDate(baseDate.getDate() - Math.floor(Math.random() * 7));\n      return baseDate.toISOString();\n    }\n  }\n  \n  private getCityImages(citySlug: string): SitemapImage[] {\n    if (!this.options.includeImages) return [];\n    \n    const cityName = formatCityName(citySlug);\n    const cityUrlSlug = citySlug.replace('-tx', '');\n    \n    return [\n      {\n        loc: `${this.baseUrl}/images/cities/${cityUrlSlug}-electricity-plans.jpg`,\n        title: `Electricity Plans in ${cityName}, Texas`,\n        caption: `Compare electricity rates and providers in ${cityName}`,\n        geoLocation: `${cityName}, TX`\n      },\n      {\n        loc: `${this.baseUrl}/images/cities/${cityUrlSlug}-skyline.jpg`,\n        title: `${cityName} City Skyline`,\n        caption: `${cityName}, Texas - served by competitive electricity providers`\n      }\n    ];\n  }\n  \n  private getFilterImages(citySlug: string, filters: string[]): SitemapImage[] {\n    if (!this.options.includeImages || filters.length === 0) return [];\n    \n    const cityName = formatCityName(citySlug);\n    const filterText = filters.join('-');\n    \n    return [\n      {\n        loc: `${this.baseUrl}/images/plans/${filterText}-${citySlug}.jpg`,\n        title: `${filters.map(f => f.replace('-', ' ')).join(' ')} electricity plans`,\n        caption: `${filters.map(f => f.replace('-', ' ')).join(' ')} electricity plans in ${cityName}`,\n        geoLocation: `${cityName}, TX`\n      }\n    ];\n  }\n  \n  private getCityAlternates(citySlug: string): SitemapAlternate[] {\n    const cityUrlSlug = citySlug.replace('-tx', '');\n    return [\n      {\n        hreflang: 'en',\n        href: `${this.baseUrl}/texas/${cityUrlSlug}/`\n      },\n      {\n        hreflang: 'x-default',\n        href: `${this.baseUrl}/texas/${cityUrlSlug}/`\n      }\n    ];\n  }\n  \n  private getFilterAlternates(citySlug: string, filters: string[]): SitemapAlternate[] {\n    const cityUrlSlug = citySlug.replace('-tx', '');\n    const filterPath = filters.join('/');\n    return [\n      {\n        hreflang: 'en',\n        href: `${this.baseUrl}/texas/${cityUrlSlug}/${filterPath}/`\n      }\n    ];\n  }\n  \n  private chunkArray<T>(array: T[], chunkSize: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += chunkSize) {\n      chunks.push(array.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n  \n  private renderSitemapIndex(sitemaps: SitemapIndex[]): string {\n    const sitemapElements = sitemaps.map(sitemap => {\n      return `  <sitemap>\n    <loc>${sitemap.loc}</loc>\n    <lastmod>${sitemap.lastmod}</lastmod>\n  </sitemap>`;\n    }).join('\\n');\n    \n    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sitemapindex xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n${sitemapElements}\n</sitemapindex>`;\n  }\n  \n  private renderSitemap(urls: SitemapUrl[]): string {\n    const urlElements = urls.map(url => {\n      let urlElement = `  <url>\n`;\n      urlElement += `    <loc>${url.loc}</loc>\n`;\n      urlElement += `    <lastmod>${url.lastmod}</lastmod>\n`;\n      urlElement += `    <changefreq>${url.changefreq}</changefreq>\n`;\n      urlElement += `    <priority>${url.priority.toFixed(1)}</priority>\n`;\n      \n      // Add image elements\n      if (url.images && url.images.length > 0) {\n        url.images.forEach(image => {\n          urlElement += `    <image:image>\n`;\n          urlElement += `      <image:loc>${image.loc}</image:loc>\n`;\n          if (image.title) urlElement += `      <image:title>${image.title}</image:title>\n`;\n          if (image.caption) urlElement += `      <image:caption>${image.caption}</image:caption>\n`;\n          if (image.geoLocation) urlElement += `      <image:geo_location>${image.geoLocation}</image:geo_location>\n`;\n          urlElement += `    </image:image>\n`;\n        });\n      }\n      \n      // Add alternate elements\n      if (url.alternates && url.alternates.length > 0) {\n        url.alternates.forEach(alternate => {\n          urlElement += `    <xhtml:link rel=\"alternate\" hreflang=\"${alternate.hreflang}\" href=\"${alternate.href}\" />\n`;\n        });\n      }\n      \n      urlElement += `  </url>`;\n      return urlElement;\n    }).join('\\n');\n    \n    let namespaces = 'xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\"';\n    if (this.options.includeImages) {\n      namespaces += ' xmlns:image=\"http://www.google.com/schemas/sitemap-image/1.1\"';\n    }\n    if (this.options.includeAlternates) {\n      namespaces += ' xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"';\n    }\n    \n    return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset ${namespaces}>\n${urlElements}\n</urlset>`;\n  }\n  \n  // Additional helper methods for analytics\n  private getStaticPageCount(): number { return 25; }\n  private getProviderUrlCount(): number { return 150; }\n  private getEducationalUrlCount(): number { return 75; }\n  private getImageUrlCount(): number { return 500; }\n  private getMobileUrlCount(): number { return 1000; }\n  private getSeasonalUrlCount(season: string): number { return 200; }\n  \n  private groupFiltersByValue(): Record<string, string[]> {\n    return {\n      'high': ['12-month', '24-month', 'fixed-rate', 'green-energy'],\n      'medium': ['prepaid', 'no-deposit', 'variable-rate'],\n      'low': ['time-of-use', 'indexed-rate', 'some-green']\n    };\n  }\n  \n  private estimateFilterUrlCount(filters: string[]): number {\n    return filters.length * 50; // Rough estimate\n  }\n  \n  private calculateTotalSitemapCount(): number {\n    const cityGroups = this.groupCitiesByImportance();\n    let count = 5; // Base sitemaps\n    \n    Object.entries(cityGroups).forEach(([tier, cities]) => {\n      const avgUrls = this.getAverageUrlsPerCity(parseInt(tier));\n      const totalUrls = cities.length * avgUrls;\n      count += Math.ceil(totalUrls / this.options.maxUrlsPerSitemap);\n    });\n    \n    return count;\n  }\n  \n  private calculatePriorityDistribution(totalUrls: number): Record<string, number> {\n    return {\n      'high (0.8-1.0)': Math.round(totalUrls * 0.15),\n      'medium (0.5-0.7)': Math.round(totalUrls * 0.35),\n      'low (0.1-0.4)': Math.round(totalUrls * 0.50)\n    };\n  }\n  \n  private analyzeCrawlBudgetEfficiency(totalUrls: number): CrawlBudgetAnalysis {\n    return {\n      efficiency: totalUrls <= 10000 ? 'excellent' : totalUrls <= 25000 ? 'good' : 'needs-optimization',\n      estimatedCrawlTime: `${Math.ceil(totalUrls / 1000)} days`,\n      priorityUrlsRatio: 0.50,\n      recommendations: totalUrls > 25000 ? [\n        'Consider increasing priority threshold to reduce low-value URLs',\n        'Implement more aggressive canonical consolidation',\n        'Review filter combination value proposition'\n      ] : ['Current sitemap size is optimal for crawl budget']\n    };\n  }\n  \n  private estimateCrawlTime(totalUrls: number): string {\n    // Assume Google crawls 1000 URLs per day for average sites\n    const daysToFullCrawl = Math.ceil(totalUrls / 1000);\n    return `${daysToFullCrawl} days for complete crawl`;\n  }\n  \n  private generateOptimizationRecommendations(totalUrls: number, priorityDist: Record<string, number>): string[] {\n    const recommendations: string[] = [];\n    \n    if (totalUrls > 15000) {\n      recommendations.push('Consider implementing more aggressive canonical consolidation');\n    }\n    \n    if (priorityDist['low (0.1-0.4)'] / totalUrls > 0.6) {\n      recommendations.push('Too many low-priority URLs - increase priority threshold');\n    }\n    \n    if (this.options.seasonalOptimization) {\n      recommendations.push('Seasonal sitemaps are active - review quarterly for relevance');\n    }\n    \n    return recommendations;\n  }\n}\n\n/**\n * Interfaces for analytics and monitoring\n */\nexport interface SitemapAnalytics {\n  totalUrls: number;\n  totalCities: number;\n  cityTiers: {\n    tier1: number;\n    tier2: number;\n    tier3: number;\n  };\n  sitemapCount: number;\n  priorityDistribution: Record<string, number>;\n  crawlBudgetAnalysis: CrawlBudgetAnalysis;\n  lastGenerated: string;\n  estimatedCrawlTime: string;\n  recommendations: string[];\n}\n\nexport interface CrawlBudgetAnalysis {\n  efficiency: 'excellent' | 'good' | 'needs-optimization';\n  estimatedCrawlTime: string;\n  priorityUrlsRatio: number;\n  recommendations: string[];\n}\n\n/**\n * Export utility functions for Astro endpoints\n */\nexport function generateOptimizedSitemapIndex(options?: Partial<SitemapGenerationOptions>): string {\n  const generator = new AdvancedSitemapGenerator(options);\n  return generator.generateAdvancedSitemapIndex();\n}\n\nexport function generateOptimizedCitySitemap(tier: number, chunk: number = 0, options?: Partial<SitemapGenerationOptions>): string {\n  const generator = new AdvancedSitemapGenerator(options);\n  return generator.generateCityTierSitemap(tier, chunk);\n}\n\nexport function generateOptimizedRobotsTxt(options?: Partial<SitemapGenerationOptions>): string {\n  const generator = new AdvancedSitemapGenerator(options);\n  return generator.generateAdvancedRobotsTxt();\n}\n\nexport function getSitemapAnalytics(options?: Partial<SitemapGenerationOptions>): SitemapAnalytics {\n  const generator = new AdvancedSitemapGenerator(options);\n  return generator.generateSitemapAnalytics();\n}